---
title: "Closures"
categories:
  - TIL
tags:
  - learning
  - ê³µë¶€ ê¸°ë¡
  - Swift
  - Closures
show_date: true
toc: true
toc_sticky: true
toc_label: "ğŸ“‚"
toc_icon: "kiwi-bird"
#header:
#  teaser: /assets/images/choose2.png
---
[Closures](https://docs.swift.org/swift-book/LanguageGuide/Closures.html)
<sub>ì•„ë˜ ëª¨ë“  ì •ë³´ì˜ ì¶œì²˜ëŠ” Swift ê³µì‹ ë¬¸ì„œì´ë©° ê°œì¸ì˜ í•™ìŠµ ìš©ë„ë¡œë§Œ ì‚¬ìš©ë˜ì—ˆìŒì„ ë°í™ë‹ˆë‹¤.  
All information below comes from the Swift documentation and is for personal learning purposes only.</sub>

# { }
  ClosuresëŠ” ê¸°ëŠ¥ì„ ë‹´ê³  ìˆëŠ” ì™„ì „í•œ ë¸”ë½ìœ¼ë¡œ ì½”ë“œ ì•ˆì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
  Constantsì™€ Variablesì˜ referencesë¥¼ ì°¾ì•„ë‚´ê³  ë‹´ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
  ì´ê²ƒì„ *closing over* constants and variablesí•œë‹¤ê³  í•©ë‹ˆë‹¤.

  SwiftëŠ” capturingê³¼ ê´€ë ¨ëœ ëª¨ë“  ë©”ëª¨ë¦¬ ê´€ë¦¬ë¥¼ ì²˜ë¦¬í•´ì¤ë‹ˆë‹¤.  

## Functions and Closures

  ì „ì—­ë²”ìœ„ì˜ function ê·¸ë¦¬ê³  nested funtionsëŠ” ëª¨ë‘ ì‚¬ì‹¤ íŠ¹ë³„í•œ ì¼€ì´ìŠ¤ì˜ closuresì…ë‹ˆë‹¤.  
  í´ë¡œì €ëŠ” ì„¸ê°€ì§€ í˜•íƒœë¡œ ë‚˜ëˆ ì§‘ë‹ˆë‹¤.  

  1. Global functionsëŠ” ì´ë¦„ì„ ê°€ì§€ê³  ìˆì§€ë§Œ ì–´ë–¤ ê°’ë„ captureí•˜ì§€ ì•ŠëŠ” í´ë¡œì €ì…ë‹ˆë‹¤.
  2. Nested functionsëŠ” ì´ë¦„ì„ ê°€ì§€ê³  ìˆê³  ìì‹ ì„ ê°ì‹¸ê³  ìˆëŠ” functionì˜ ê°’ì„ captureí•  ìˆ˜ ìˆëŠ” í´ë¡œì €ì…ë‹ˆë‹¤.
  3. Closure expressions ì£¼ë³€ì˜ ê°’ì„ captureí•  ìˆ˜ ìˆëŠ” ê°€ë²¼ìš´ syntaxë¡œ ì“°ì—¬ì§„, ì´ë¦„ì´ ì—†ëŠ” í´ë¡œì €ì…ë‹ˆë‹¤.  

## Closure Expressions  

  Swiftì˜ **closure expressions**ëŠ” ê°„ê²°í•˜ê³  ê¹”ë”í•˜ë„ë¡ ìµœì í™”ëœ syntaxì™€ í•¨ê»˜ ëª…í™•í•œ ìŠ¤íƒ€ì¼ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.  
  ì´ ìµœì í™”ëŠ” ì•„ë˜ì˜ ë„¤ê°€ì§€ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.  

  1. íŒ¨ëŸ¬ë¯¸í„°ì™€ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì„ ë¬¸ë§¥ì˜ íë¦„ìœ¼ë¡œë¶€í„° ì¶”ë¡ í•©ë‹ˆë‹¤.
  2. single-expressions closuresë¡œë¶€í„°ì˜ í‚¤ì›Œë“œë¡œ í‘œí˜„ë˜ì§€ ì•Šì€ returns
  3. ì•½ì¹­ìœ¼ë¡œ ëœ argumentì˜ ì´ë¦„
  4. Trailing closure syntax ğŸ‘·

  Closure expressionsëŠ” inline closuresë¥¼ ì§§ê³  ì§‘ì¤‘ëœ í˜•íƒœì˜ syntaxë¡œ ì‘ì„±í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.

  <div class="notice">
     <h4>ğŸ’¡</h4>
     <p>inlineì€ ì‚¬ìš©ë˜ê¸° ì „ì— ì¤‘ê°„ ë³€ìˆ˜ì— í• ë‹¹ë˜ì§€ ì•Šê³  ë°”ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒì„ ë§í•©ë‹ˆë‹¤.
     </p>
  </div>  

  Closure expressionsëŠ” closuresë¥¼ ì •í™•í•¨ê³¼ ì˜ë„ë¥¼ ìƒì§€ ì•Šìœ¼ë©´ì„œ ë‹¨ì¶•ëœ í˜•íƒœë¡œ ì‘ì„±í•˜ê¸° ìœ„í•œ ëª‡ëª‡ê°œì˜ syntax ìµœì í™”ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

### The Sorted Method  

  Swiftì˜ standard libraryëŠ” sorted(by:)ë¥¼ ì œê³µí•©ë‹ˆë‹¤. íƒ€ì…ì´ ëª…í™•í•˜ê²Œ ë°í˜€ì§„ ê°’ì„ ê°€ì§€ê³  ìˆëŠ” ë°°ì—´ì„ ì •ë ¬í•˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤. ì£¼ì–´ì§„ sorting closureì˜ ì¶œë ¥ê²°ê³¼ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë°°ì—´ì˜ ê°’ì„ ì •ë ¬í•©ë‹ˆë‹¤. ì •ë ¬í•˜ëŠ” ê³¼ì •ì´ ì™„ë£Œë˜ë©´ sorted(by:) ë©”ì„œë“œëŠ” íƒ€ì…ê³¼ ì‚¬ì´ì¦ˆëŠ” ê°™ì§€ë§Œ ì¡°ê±´ëŒ€ë¡œ ì •ë ¬ëœ ìƒˆë¡œìš´ ë°°ì—´ì„ ë¦¬í„´í•©ë‹ˆë‹¤. ì›ë˜ì˜ ë°°ì—´ì€ ìˆ˜ì •ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  

  ì•„ë˜ì˜ closure expressionsì˜ ì˜ˆì œëŠ” String typeì˜ ê°’ì„ ê°€ì§„ namesë¼ëŠ” ë°°ì—´ì„ ì•ŒíŒŒë²³ ìˆœì„œì˜ ë°˜ëŒ€ë¡œ ì •ë ¬í•  ê²ƒì…ë‹ˆë‹¤.

  ```swift
  let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
  ```
  sorted(by:)ë©”ì„œë“œëŠ” ë°°ì—´ì˜ contentsì™€ ê°™ì€ ìë£Œí˜•ì˜ arguments ë‘ê°œë¥¼ ë°›ì•„ë“¤ì´ëŠ” closureë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ê°’ë“¤ì´ ì •ë ¬ë˜ë©´ ì²«ë²ˆì§¸ ê°’ì´ ë‘ë²ˆì§¸ ê°’ì˜ ì „, ë˜ëŠ” í›„ì— ë‚˜íƒ€ë‚˜ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì•Œë ¤ì£¼ëŠ” Bool ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤. ì´ sorting closureëŠ” ì²«ë²ˆì§¸ ê°’ì´ ë‘ë²ˆì§¸ ê°’ ì „ì— ë‚˜íƒ€ë‚˜ì•¼ í•œë‹¤ë©´ trueë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ë°˜ëŒ€ ìƒí™©ì—ì„œëŠ” falseë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤.  

  ì´ ì˜ˆì‹œëŠ” Stringê°’ì˜ ë°°ì—´ì„ ì •ë ¬í•˜ë¯€ë¡œ sorting closureëŠ” (String, String) -> Bool íƒ€ì…ì˜ functionì´ í•„ìš”í•©ë‹ˆë‹¤.  

#### The sorting closure: ë°©ì‹1

  ì´ sorting closureë¥¼ ì œê³µí•˜ëŠ” í•œ ë°©ì‹ìœ¼ë¡œëŠ”, **functionì„ ì‘ì„±**í•˜ê³  sorted(by:)ë©”ì„œë“œì˜ ì¸ìë¡œ í†µê³¼ì‹œí‚¤ëŠ” ë°©ë²•ì´ ìˆìŠµë‹ˆë‹¤.

  ```swift
  fucn backward(_ s1: String, _ s2: String) -> Bool {
      return s1 > s2
  }
  var reversedNames = names.sorted(by: backward)
  // reversedNames = ["Ewa", "Daniella", "Chris", "Barry", "Alex"]
  ```
  ë§Œì•½ ì²«ë²ˆì§¸ ë¬¸ìì—´(s1)ì´ ë‘ë²ˆì§¸ ë¬¸ìì—´(s2)ë³´ë‹¤ í¬ë‹¤ë©´, backward functionì€ trueë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤. ì´ê²ƒì€ ì •ë ¬ëœ ë°°ì—´ì—ì„œ s1ì´ s2ì „ì— ë‚˜íƒ€ë‚˜ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì•ŒíŒŒë²³ì—ì„œëŠ” ë’¤ë¡œ ê°ˆìˆ˜ë¡ í° ê°’ì´ê¸° ë•Œë¬¸ì— ì•ŒíŒŒë²³ì˜ ì—­ìˆœìœ¼ë¡œ ì •ë ¬ë©ë‹ˆë‹¤.  

  ìœ„ì˜ ë°©ë²•ì€ ê¼­ í•„ìš”í•œ single expression function (a > b)ë¥¼ ì‘ì„±í•œ ê¸´ ë²„ì „ì˜ ë°©ë²•ì´ì—ˆìŠµë‹ˆë‹¤.

#### The sorting closure: ë°©ì‹2  

  **Closure Expression Syntax**ë¥¼ ì´ìš©í•´ì„œ inline ë°©ì‹ìœ¼ë¡œ sorting closureë¥¼ ì‘ì„±í•˜ëŠ” ê²ƒì´ ë” ë‚˜ì€ ë°©ì‹ì´ ë  ê²ƒì…ë‹ˆë‹¤.  

  Closure Expression Syntaxì˜ ì¼ë°˜ì ì¸ í˜•íƒœ:

  ```swift
  { ( parameters ) -> return type in
      statements
  }
  ```

  Closure expression syntaxì˜ íŒ¨ëŸ¬ë¯¸í„°ëŠ” in-out íŒ¨ëŸ¬ë¯¸í„° ë‘˜ ë‹¤ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ default ê°’ì€ ê°€ì§ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì•„ë˜ì˜ ì˜ˆì‹œëŠ” closure expression ë²„ì „ì˜ backward functionì…ë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted(by: { (s1: String, s2: String) -> Bool in
        return s1 > s2
  })
  ```

  ìœ„ì˜ inline closureì˜ íŒ¨ëŸ¬ë¯¸í„°ì™€ ë¦¬í„´ íƒ€ì…ì„ ì •ì˜í•œ ë°©ì‹ì€ backward functionì˜ ì •ì˜í•œ ë°©ì‹ê³¼ ë˜‘ê°™ìŠµë‹ˆë‹¤. ë‘˜ë‹¤ (s1: String, s2: String) -> Bool ì´ë¼ê³  ì“°ì˜€ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ inline closure expressionì—ì„œëŠ” { } ë°–ì´ ì•„ë‹ˆë¼ ì•ˆì— ì‘ì„±ë˜ì—ˆë‹¤ëŠ” ì°¨ì´ì ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  ë°”ë”” ë¶€ë¶„ì˜ ì‹œì‘ì„ in í‚¤ì›Œë“œë¡œ ì•Œë ¸ìŠµë‹ˆë‹¤. in í‚¤ì›Œë“œëŠ” í´ë¡œì €ì˜ íŒ¨ëŸ¬ë¯¸í„°ì™€ ë¦¬í„´ íƒ€ì…ì˜ ì •ì˜ê°€ ëë‚¬ë‹¤ëŠ” ê²ƒì„ ì•Œë ¤ì£¼ê³  ë°”ë”” ë¶€ë¶„ì´ ì‹œì‘ëœë‹¤ëŠ” ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.  

#### Inferring Type From Context

  ìœ„ì˜ sorting closureê°€ sorted(by:) ë©”ì„œë“œì˜ argumentë¡œ í†µê³¼ë˜ê¸° ë•Œë¬¸ì— SwiftëŠ” sorting closureì˜ íŒ¨ëŸ¬ë¯¸í„°ì˜ íƒ€ì…ê³¼ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì„ ì¶”ì¸¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— íŒ¨ëŸ¬ë¯¸í„°ì™€ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì€ ì‘ì„±ë  í•„ìš”ê°€ ì—†ì–´ì§‘ë‹ˆë‹¤. ëª¨ë“  íƒ€ì…ë“¤ì´ ì¶”ì¸¡ ê°€ëŠ¥í•´ì§ìœ¼ë¡œ return arrow(->)ì™€ íŒ¨ëŸ¬ë¯¸í„°ë¥¼ ê°ì‹¸ëŠ” ê´„í˜¸ ë˜í•œ ìƒëµ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted(by: { s1, s2 in return s1 > s2 } )
  ```
  Functionì´ë‚˜ methodì— closureë¥¼ í†µê³¼ì‹œí‚¬ë•ŒëŠ” ì–¸ì œë‚˜ íŒ¨ëŸ¬ë¯¸í„° íƒ€ì…ê³¼ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì„ ì¶”ì¸¡í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ê·¸ë ‡ê¸° ë•Œë¬¸ì— functionì´ë‚˜ methodì˜ ì¸ìë¡œì¨ inline closureì„ ì‚¬ìš©í•  ë•ŒëŠ” ì™„ì „í•œ í˜•íƒœë¡œ ì‘ì„±í•  í•„ìš”ê°€ ì—†ì–´ì§‘ë‹ˆë‹¤.  

  ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , ì›í•œë‹¤ë©´ ìë£Œí˜•ì„ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ ì½”ë“œë¥¼ ì½ì–´ì•¼í•˜ëŠ” ì‚¬ëŒë“¤ì„ ìœ„í•´ ëª¨í˜¸í•œ ë¶€ë¶„ì„ í”¼í•˜ê³  ì‹¶ë‹¤ë©´ ìë£Œí˜•ì„ ëª…ì‹œí•˜ëŠ” ê²ƒì€ ì¢‹ì€ ë°©ë²•ì´ ë  ê²ƒì…ë‹ˆë‹¤.

#### Implicit Returns from Single-Expression closures

  Single-expression closuresëŠ” return í‚¤ì›Œë“œë¥¼ ìƒëµí•˜ê³  single expressionì˜ ê²°ê³¼ë¥¼ ë¦¬í„´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted(by: { s1, s2 in s1 > s2 } )
  ```

#### Shorthand Argument Names  

  SwiftëŠ” inline closuresì˜ argument ì´ë¦„ì„ ê°„ë‹¨í•˜ê²Œ ì „ë‹¬í•˜ëŠ” ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. $0, $1, $2 ë“±ìœ¼ë¡œ í´ë¡œì €ì˜ ì¸ìê°’ì„ ë‚˜íƒ€ë‚¼ ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤.  

  ë§Œì•½ closure expressionì—ì„œ ì´ shorthand argument namesë¥¼ ì‚¬ìš©í•œë‹¤ë©´, í´ë¡œì €ì˜ argument listë¥¼ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. shorthand argument namesì˜ ìë£Œí˜•ì€ ì‚¬ìš©ë˜ê¸¸ ì˜ˆìƒë˜ëŠ” functionì˜ ìë£Œí˜•ìœ¼ë¡œë¶€í„° ì¶”ì¸¡ ê°€ëŠ¥í•˜ê³ , ê°€ì¥ ë†’ì€ ìˆ˜ì˜ shorthand argumentëŠ” í•´ë‹¹ í´ë¡œì €ê°€ ì‚¬ìš©í•  argumentì˜ ê°œìˆ˜ë¥¼ ê²°ì •í•©ë‹ˆë‹¤. ì´ closure expressionì˜ ì „ì²´ê°€ ë°”ë””ë¶€ë¶„ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìŒìœ¼ë¡œ in í‚¤ì›Œë“œë„ ìƒëµì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted(by: { $0 > $1 } )
  ```

  ìœ„ì˜ ì˜ˆì‹œì—ì„œ, $0ì€ ì²«ë²ˆì§¸ String argumentë¥¼ $1 ì€ ë‘ë²ˆì§¸ String argumentë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. $1ì´ ê°€ì¥ ë†’ì€ ìˆ«ìì˜ shorthand argumentë¼ëŠ” ê²ƒì€ í•´ë‹¹ í´ë¡œì €ê°€ ë‘ê°œì˜ argumentsë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

#### Operator Methods  

  ì‹¬ì§€ì–´ ë” ì§§ì€ ë°©ì‹ìœ¼ë¡œ closure expressionì„ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Swiftì˜ String typeì€ greater-than operator(>)ì˜ íŠ¹ì • ì´í–‰ ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ ë©”ì„œë“œì˜ íŒ¨ëŸ¬ë¯¸í„° íƒ€ì…ê³¼ ë¦¬í„´ íƒ€ì…ì´ sorted(by:)ë©”ì„œë“œì—ê²Œ í•„ìš”í•œ íŒ¨ëŸ¬ë¯¸í„° íƒ€ì…, ê·¸ë¦¬ê³  ë¦¬í„´ íƒ€ì…ê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ê¸° ë•Œë¬¸ì— ë‹¨ìˆœíˆ > í•˜ë‚˜ë§Œ í†µê³¼ì‹œí‚¤ë”ë¼ë„ SwiftëŠ” String íƒ€ì…ì˜ string-specific implementationì„ ì‚¬ìš©í•˜ê¸¸ ì›í•œë‹¤ëŠ” ê²ƒì„ ì¶”ë¡ í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted(by: > )
  ```

#### Trailing closures  

  Closure expressionì„ ì–´ë–¤ functionì˜ ë§ˆì§€ë§‰ argumentë¡œ í†µê³¼ì‹œì¼œì•¼ í•˜ê³  ê·¸ closure expressionì´ ê¸¸ë‹¤ë©´, í•´ë‹¹ closure expressionì„ trailing closureë¡œ ì‘ì„±í•˜ëŠ” ê²ƒì´ ìœ ìš©í•œ ë°©ë²•ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‚¬ìš©í•˜ëŠ” trailing closureê°€ functionì˜ argumentì´ë”ë¼ë„  function callì˜ () ë’¤ì— trailing closureì„ ì‘ì„±í•©ë‹ˆë‹¤. ì´ trailing closure syntaxë¥¼ ì‚¬ìš©í• ë•ŒëŠ” functionì„ í˜¸ì¶œí•  ë•Œ ì²«ë²ˆì§¸ closureì˜ argument label (closure: // ê°™ì€)ì€ ì‘ì„±í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì•„ë˜ì˜ ì˜ˆì œëŠ” single trailing closureë¥¼ ì‚¬ìš©í•˜ê³  ìˆì§€ë§Œ í•˜ë‚˜ì˜ function callì´ ì—¬ëŸ¬ê°œì˜ trailing closuresë¥¼ í¬í•¨í•  ìˆ˜ ì‡ìŠµë‹ˆë‹¤.

  ```swift
  func someFunctionThatTakesAClosure(closure: () -> Void) {
      // funtion body ë¶€ë¶„
  }

  // trailing closureë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ìœ„ì˜ functionì„ í˜¸ì¶œí•˜ëŠ” ë°©ë²•
  someFunctionThatTakesAClosure(closure: {
      // closureì˜ ë°”ë”” ë¶€ë¶„
    })

  // trailing closure ì‚¬ìš©
  someFunctionThatTakesAClosure() {
      // trailing closureì˜ ë°”ë”” ë¶€ë¶„
  }  
  ```

  ìœ„ì—ì„œ ì‘ì„±í•´ë³´ì•˜ë˜ string-sorting closureë„ sorted(by:)ë©”ì„œë“œì˜ ê´„í˜¸ ë°–ì—ì„œ trailing closureë¡œ ì‘ì„±ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted() { $0 > $1 }
  ```

  ë§Œì•½ closure expressionì´ functionì´ë‚˜ methodì˜ ìœ ì¼í•œ argumentì´ê³  trailing closureë¡œ ì‘ì„±í•œë‹¤ë©´ ()ë¥¼ ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```swift
  reversedNames = names.sorted { $0 > $1 }
  ```

  Trailing closuresëŠ” ì–´ë–¤ closureê°€ í•œ ì¤„ ìœ„ì— inline í˜•ì‹ìœ¼ë¡œ ì‘ì„±ì´ ì–´ë ¤ìš¸ ì •ë„ë¡œ ê¸¸ì´ê°€ ê¸¸ ë•Œ ê°€ì¥ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, Swiftì˜ Array typeì€ map(_:) ë©”ì„œë“œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ ë©”ì„œë“œëŠ” í•˜ë‚˜ì˜ closure expressionì„ argumentë¡œ ê°€ì§‘ë‹ˆë‹¤. í•´ë‹¹ í´ë¡œì €ëŠ” ë°°ì—´ì˜ ê° ì•„ì´í…œë§ˆë‹¤ í•œë²ˆì”© í˜¸ì¶œë©ë‹ˆë‹¤. ê·¸ë¦¬ê³  í•´ë‹¹ itemì„ ë‹¤ë¥´ê²Œ mappedëœ valueë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤. (ë‹¤ë¥¸ íƒ€ì…ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.) map(\_:) ë©”ì„œë“œì— í†µê³¼ì‹œí‚¬ í´ë¡œì € ì•ˆì— ì½”ë“œë¥¼ ì‘ì„±í•¨ìœ¼ë¡œì¨ mappingì˜ ì¢…ë¥˜ì™€ ë¦¬í„´ ê°’ì˜ íƒ€ì…ì„ íŠ¹ì • ì§“ìŠµë‹ˆë‹¤.  

  ì£¼ì–´ì§„ í´ë¡œì €ë¥¼ ë°°ì—´ì˜ ê° ìš”ì†Œë§ˆë‹¤ ì ìš©í•œ ë’¤ì—, map(_:) ë©”ì„œë“œëŠ” ìƒˆë¡œ mappedëœ ê°’ì„ ì›ë˜ì˜ ì—°ê²°ëœ ë°°ì—´ì˜ ê°’ê³¼ ê°™ì€ ìˆœì„œë¡œ ë‹´ê³  ìˆëŠ” ìƒˆ ë°°ì—´ì„ ë¦¬í„´í•©ë‹ˆë‹¤.

  ì•„ë˜ ì˜ˆì‹œëŠ” map(_:)ë©”ì„œë“œì™€ trailing closureë¥¼ ì‚¬ìš©í•˜ì—¬ Int íƒ€ì…ì˜ ê°’ì„ ê°€ì§€ê³  ìˆëŠ” ë°°ì—´ì„ String íƒ€ì…ì˜ ê°’ì„ ê°€ì§„ ë°°ì—´ë¡œ ë³€í™˜í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤. ë°°ì—´ [16, 58, 510]ì€ ìƒˆë¡œìš´ ë°°ì—´ì¸ ["OneSix", "FiveEight", "FiveOneZero"]ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.

  ```swift
  let digitNames = [
      0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four",
      5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
  ]
  let numbers = [16, 58, 510]
  ```  
  ìœ„ì˜ ì½”ë“œëŠ” ìˆ«ìì™€ ì˜ì–´ ë²„ì „ì˜ ìˆ«ì ì´ë¦„ì„ ë§µí•‘í•œ dictionaryë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ë¬¸ìì—´ ë°°ì—´ë¡œ ë³€í™˜ë  numbers ë°°ì—´ë„ ì •ì˜í•©ë‹ˆë‹¤.  

  Array íƒ€ì…ì˜ map(_:)ë©”ì„œë“œì— trailing clousreë¡œ closure expressionì„ í†µê³¼ì‹œì¼œ numbers ë°°ì—´ì„ ë¬¸ìì—´ ë°°ì—´ë¡œ ë§Œë“¤ì–´ ë´…ë‹ˆë‹¤.  

  ```swift
  let string = numbers.map { (number) -> String in
      var number = number
      var output = ""
      repeat {
          output = digitNames[number % 10]! + output
          number /= 10
      } while number > 0
      return output
  }
  // strings ìƒìˆ˜ì˜ íƒ€ì…ì€ [String]ìœ¼ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤.
  // ê°’ì€ ["OneSix", "FiveEight", "FiveOneZero"] ì…ë‹ˆë‹¤.
  ```
  map(_:) ë©”ì„œë“œëŠ” numbers ë°°ì—´ì•ˆì˜ ê° itemë§ˆë‹¤ closure expressionì„ í˜¸ì¶œí•©ë‹ˆë‹¤. ë§µí•‘ë  ë°°ì—´ì˜ ê°’ìœ¼ë¡œë¶€í„° íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— í´ë¡œì €ì˜ ì¸í’‹ íŒ¨ëŸ¬ë¯¸í„°ì¸ numberì˜ íƒ€ì…ì„ íŠ¹ì •ì§€ì„ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.

  ìœ„ì˜ ì˜ˆì‹œì—ì„œ var numberëŠ” ì´ˆê¸°ê°’ìœ¼ë¡œ closureì˜ íŒ¨ëŸ¬ë¯¸í„°ì¸ numberë¥¼ ê°€ì§‘ë‹ˆë‹¤. ì´ë ‡ê²Œ í•¨ìœ¼ë¡œì¨ í´ë¡œì €ì˜ ë°”ë””ì•ˆì—ì„œ ê·¸ ê°’ì´ ë³€ê²½ë  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤. (function ë˜ëŠ” closuresì˜ íŒ¨ëŸ¬ë¯¸í„°ëŠ” ì–¸ì œë‚˜ constants ì´ê¸° ë•Œë¬¸ì—) ì´ closure expressionì€ ë˜í•œ mapped output ë°°ì—´ì•ˆì˜ ë‹´ê¸¸ ê°’ì˜ íƒ€ì…ì„ ë‚˜íƒ€ë‚´ê¸°ìœ„í•´ ë¦¬í„´ íƒ€ì…ì„ Stringìœ¼ë¡œ íŠ¹ì • ì§€ì—ˆìŠµë‹ˆë‹¤.  

  ìœ„ì˜ closure expressionì€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ ouputì´ë¼ëŠ” ì´ë¦„ì˜ ë¬¸ìì—´ì„ ë§Œë“­ë‹ˆë‹¤. ì´ê²ƒì€ remainder operator (number % 10)ì„ ì‚¬ìš©í•˜ì—¬ numberì˜ ë§ˆì§€ë§‰ ìˆ˜ë¥¼ ì°¾ì•„ë‚´ê³  ì´ë ‡ê²Œ ì°¾ì•„ë‚¸ ìˆ«ìë¥¼ digitNames dictionaryì—ì„œ í‚¤ ê°’ìœ¼ë¡œ ê°€ì§€ëŠ” ê°’ì„ ì°¾ê¸° ìœ„í•´ ì‚¬ìš©í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ì°¾ì€ ë¬¸ìì—´ ê°’ì„ í˜„ì¬ output ë¬¸ìì—´ê³¼ í•©ì¹©ë‹ˆë‹¤. ì´ í´ë¡œì €ëŠ” 0ë³´ë‹¤ í° ì–´ë–¤ ìˆ«ìë¥¼ ë¬¸ì í˜•ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í´ë¡œì €ê°€ output ê°’ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ ìƒˆë¡œìš´ ë°°ì—´ì´ map(_:) ë©”ì„œë“œë¡œë¶€í„° ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤.  

  ìœ„ì˜ ì˜ˆì‹œì—ì„œì˜ trailing closureì˜ ì‚¬ìš©ì€ í´ë¡œì €ê°€ ì‚¬ìš©ëœ function ë°”ë¡œ ë’¤ì— í´ë¡œì €ì˜ ê¸°ëŠ¥ì„ ë°”ë¡œ ìš”ì•½í•´ì„œ ë‚˜íƒ€ë‚´ì¤ë‹ˆë‹¤. map(_:)ì˜ ê´„í˜¸ë¡œ ê°ìŒ€ í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.  

## Capturing Values  

  í´ë¡œì €ëŠ” constantsë‚˜ variablesê°€ ì •ì˜ëœ ê³³ ì•ˆì—ì„œ constantsë‚˜ variablesë¥¼ *capture*í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³ ë‚˜ì„œ í•´ë‹¹ í´ë¡œì €ì˜ ë°”ë”” ì•ˆì—ì„œ ìº¡ì³í•œ í•´ë‹¹ ê°’ì„ ì¡°íšŒí•˜ê±°ë‚˜ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì‹¬ì§€ì–´ í•´ë‹¹ constantsë‚˜ variablesê°€ ë”ì´ìƒ ì›ë˜ì˜ ë²”ìœ„ì•ˆì— ì¡´ì¬í•˜ì§€ ì•Šë”ë¼ë„ í´ë¡œì €ëŠ” í•´ë‹¹ ê°’ì„ ì¡°íšŒ, ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

  Swiftì—ì„œ ê°’ì„ captureí•  ìˆ˜ ìˆëŠ” ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœì˜ í´ë¡œì €ëŠ” ë°”ë¡œ ë‹¤ë¥¸ functionì˜ ë°”ë””ë¶€ë¶„ì— ì‘ì„±ëœ ested function ì…ë‹ˆë‹¤. nested functionì€ ë°”ê¹¥ìª½ functionì˜ argumentë¥¼ captureí•  ìˆ˜ ìˆê³  ë°”ê¹¥ìª½ function ì•ˆì— ì •ì˜ëœ constantsë‚˜ variablesë¥¼ captureí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ì•„ë˜ ì˜ˆì œëŠ” makeIncrementerì´ë¼ëŠ” functionì…ë‹ˆë‹¤. incrementerì´ë¼ëŠ” nested functionì„ ë‹´ê³  ìˆìŠµë‹ˆë‹¤. ì´ nested functionì¸ incrementer()ëŠ” ìì‹ ì„ ë‘˜ëŸ¬ì‹¸ê³  ìˆëŠ” ì½”ë“œì˜ ì „í›„ ê´€ê³„ë¡œë¶€í„° runningTotalê³¼ amountë¼ëŠ” ë‘ê°œì˜ ê°’ì„ captureí•©ë‹ˆë‹¤. ì´ ë‘ê°œì˜ ê°’ì„ capturing í•œ í›„, incrementerëŠ” makeIncrementerë¡œë¶€í„° í´ë¡œì €ë¡œ ë¦¬í„´ë©ë‹ˆë‹¤. incrementer í´ë¡œì €ëŠ” í˜¸ì¶œ ë  ë•Œë§ˆë‹¤ runningTotalë¥¼ amountì˜ ìˆ˜ë§Œí¼ ì¦ê°€ì‹œí‚µë‹ˆë‹¤.  

  ```swift
  func makeIncrementer(forIncrement amount: Int) -> () -> Int {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
  }
  ```
  makeIncrementer functionì˜ ë¦¬í„´ íƒ€ì…ì€ () -> Int ì…ë‹ˆë‹¤. ì´ê²ƒì€ makeIncrementer functionì´ ë‹¨ìˆœí•œ ê°’ì´ ì•„ë‹ˆë¼ functionì„ ë¦¬í„´í•œë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ ì˜ˆì œì—ì„œëŠ” ë¦¬í„´ë˜ëŠ” functionì´ íŒ¨ëŸ¬ë¯¸í„°ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šê³  í˜¸ì¶œë  ë•Œë§ˆë‹¤ Int íƒ€ì…ì˜ ê°’ì„ ë¦¬í„´í•©ë‹ˆë‹¤.

  <!-- ğŸ‘· Function Types as Return Typesì— ìì„¸í•œ ë‚´ìš© ì°¸ê³  -->

  makeIncrementer(forIncrement:)ëŠ” runningTotalì´ë¼ëŠ” integer variableì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ê²ƒì€ ë¦¬í„´ë  incrementerì˜ í˜„ì¬ runningTotalì„ ë‹´ì„ ê²ƒì…ë‹ˆë‹¤. ì´ˆê¸°ê°’ì€ 0ì…ë‹ˆë‹¤. makeIncrementer(forIncrement:) functionì€ í•˜ë‚˜ì˜ Int íŒ¨ëŸ¬ë¯¸í„°ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì´ íŒ¨ëŸ¬í„°ëŠ” forIncrementë¼ëŠ” argument lableì„ ê°€ì§€ê³  ìˆì£ . amountëŠ” íŒ¨ëŸ¬ë¯¸í„°ì˜ ì´ë¦„ì…ë‹ˆë‹¤. ì´ íŒ¨ëŸ¬ë¯¸í„°ë¡œ í†µê³¼ëœ argumentì˜ ê°’ì€ ë¦¬í„´ëœ incrementer functionì´ í˜¸ì¶œë  ë•Œë§ˆë‹¤ runningTotalì´ ì–¼ë§Œí¼ ì¦ê°€ ë ì§€ë¥¼ ì¡°ê±´ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤. makeIncrementer functionì€ incrementerì´ë¼ëŠ” ì´ë¦„ì˜ nested functionì„ ì •ì˜í•©ë‹ˆë‹¤. ì´ functionì´ ì‹¤ì œë¡œ ìˆ˜ì˜ ì¦ê°€ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤. ì´ functionì€ ë‹¨ìˆœíˆ amountë¥¼ runningTotalì— ë”í•˜ê³  ê·¸ ê²°ê³¼ë¥¼ ë¦¬í„´í•©ë‹ˆë‹¤.

  ì´ nested functionì„ ë”°ë¡œ ë–¼ì–´ë†“ê³  ë³¸ë‹¤ë©´, ì´ê²ƒì€ ì¡°ê¸ˆ íŠ¹ì´í•´ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```swift
  func incrementer() -> Int {
    runningTotal += amount
    retrun runningTotal
  }
  ```

  ì´ incrementer() functionì€ íŒ¨ëŸ¬ë¯¸í„°ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•ŠìŠµë‹ˆë‹¤. ê·¸ë¦¬ê³  runningTotalê³¼ amountë¥¼ functionì˜ ë°”ë””ë¶€ë¶„ ì•ˆì—ì„œ ì°¸ì¡°í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì€ ê°ì‹¸ê³  ìˆëŠ” functionìœ¼ë¡œë¶€í„°  runningTotalê³¼ amountì˜ referenceë¥¼ capturing í•˜ê³  ê·¸ê²ƒì„ functionì˜ ë°”ë””ë¶€ë¶„ì—ì„œ ì‚¬ìš©ëŠ” ë°©ì‹ìœ¼ë¡œ ì´ìš©ë©ë‹ˆë‹¤. Referenceë¥¼ capturingí•˜ëŠ” ê²ƒì€ makeIncrementerì— ëŒ€í•œ í˜¸ì¶œì´ ëë‚¬ì„ ë•Œë„ runningTotalê³¼ amountê°€ ì‚¬ë¼ì§€ì§€ ì•ŠëŠ” ê²ƒì„ ë³´ì¦í•©ë‹ˆë‹¤. ê·¸ë¦¬ê³  ë˜ runningTotalì´ incrementer functionì´ ë‹¤ìŒì— ë˜ í˜¸ì¶œë  ë•Œë„ ì´ìš© ê°€ëŠ¥í•˜ë„ë¡ í•©ë‹ˆë‹¤.  

  <!-- ğŸ‘· ì´ ë¶€ë¶„ ì˜ ì´í•´ê°€ ì•ˆë¨. nested functionì„ ì‚¬ìš©í•œ ì´ìœ ì¸ ê²ƒ ê°™ìŒ -->

  ì•„ë˜ëŠ” function makeIncrementerì˜ ì‚¬ìš© ì˜ˆì‹œì…ë‹ˆë‹¤.
  ```swift
  let incrementByTen = makeIncrementer(forIncrement: 10)
  ```

  ì´ ì˜ˆì‹œëŠ” incrementByTenì´ë¼ëŠ” constantë¥¼ ì„¤ì •í•˜ê³  incrementer fuctionì„ ì°¸ì¡°í•©ë‹ˆë‹¤. ì´ functionì€ í˜¸ì¶œë  ë•Œë§ˆë‹¤ 10ì„ runningTotalì— ë”í•©ë‹ˆë‹¤. ì•„ë˜ëŠ” ì—¬ëŸ¬ë²ˆ ì´ functionì„ ë¦¬í„´í–ˆì„ ë•Œì˜ ì½”ë“œì…ë‹ˆë‹¤.  

  ```swift
  incrementByTen()
  // ê°’ 10ì„ ë¦¬í„´
  incrementByTen()
  // ê°’ 20ì„ ë¦¬í„´
  incrementByTen()
  // ê°’ 30ì„ ë¦¬í„´
  ```

  ë‘ë²ˆì§¸ incrementerì„ ìƒì„±í•œë‹¤ë©´, ê·¸ê²ƒì€ ê·¸ê²ƒë§Œì˜ ë¶„ë¦¬ëœ ìƒˆë¡œìš´ runningTotal ë³€ìˆ˜ì˜ referenceë¥¼ ê°€ì§€ê²Œ ë©ë‹ˆë‹¤.

  ```swift
  let incrementBySeven = makeIncrementer(forIncrement: 7)
  incrementBySeven()
  // ê°’ 7ì„ ë¦¬í„´
  ```

  ì›ë˜ì˜ incrementerì¸ incrementByTenì„ ë‹¤ì‹œ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ê³„ì†í•´ì„œ ê·¸ê²ƒì´ ì°¸ì¡°í•œ runningTotalì˜ ê°’ì„ ì¦ê°€ì‹œí‚µë‹ˆë‹¤. ê·¸ë¦¬ê³  incrementBySevenìœ¼ë¡œë¶€í„° captureëœ ê°’ì—ëŠ” ì˜í–¥ì„ ë¯¸ì¹˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  

  ```swift
  incrementByTen()
  // ê°’ 40ì„ ë¦¬í„´
  ```

## Closures Are Reference Types

  ìœ„ì˜ ì˜ˆì‹œì—ì„œ, incrementByTenê³¼ incrementBySevenì€ constantsì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ constantsê°€ ë‚˜íƒ€ë‚´ëŠ” í´ë¡œì €ëŠ” ì—¬ì „íˆ ìº¡ì³í•œ runningTotal ë³€ìˆ˜ë¥¼ ì¦ê°€ ì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ê²ƒì´ functionsì™€ closuresê°€ reference typeì¸ ì´ìœ ì…ë‹ˆë‹¤.  

  functionì´ë‚˜ closureë¥¼ constantë‚˜ variableì— í• ë‹¹í•  ë•Œë§ˆë‹¤ ì‹¤ì œë¡œëŠ” í•´ë‹¹ constantì™€ variableì„ functionì´ë‚˜ closureì˜ referenceê°€ ë˜ë„ë¡ ì„¤ì •í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

  <!-- ğŸ‘· ëª¨ë¥´ê² ìŒ -->

  ë‘ê°œì˜ ë‹¤ë¥¸ contentsë‚˜ variablesì— í•˜ë‚˜ì˜ í´ë¡œì €ë¥¼ í• ë‹¹í•œë‹¤ë©´, ë‘ê°œ ëª¨ë‘ ë˜‘ê°™ì€ í´ë¡œì €ë¥¼ ë‚˜íƒ€ë‚´ê²Œ ë©ë‹ˆë‹¤.

  ```swift
  let alsoIncrementByTen = incrementByTen
  alsoIncrementByTen()
  // 50ì„ ë¦¬í„´

  incrementByTen()
  // 60ì„ ë¦¬í„´
  ```

  ìœ„ì˜ ì˜ˆì‹œëŠ” alsoIncrementByTenë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ incrementByTenì„ í˜¸ì¶œí•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤ëŠ” ê²ƒì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ë‘ ê°œê°€ ê°™ì€ í´ë¡œì €ë¥¼ ì°¸ì¡°í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ë‘˜ ë‹¤ ê°™ì€ runningTotalì„ ì¦ê°€ì‹œí‚¤ê³  ë¦¬í„´í•©ë‹ˆë‹¤.

## Escaping Closures  

  ```swift
  var completionHandlers: [() -> Void] = []
  func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
  }
  ```

  someFunctionWithEscapingClosure(_:) functionì€ argumentë¡œ closureë¥¼ ê°€ì§‘ë‹ˆë‹¤.
